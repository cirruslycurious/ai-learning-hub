/**
 * Invite code database operations for the invite-codes table.
 * Supports code lookup, redemption, and idempotent validation.
 */
import { randomBytes } from "crypto";
import type { DynamoDBDocumentClient } from "@aws-sdk/lib-dynamodb";
import {
  AppError,
  ErrorCode,
  type PaginatedResponse,
} from "@ai-learning-hub/types";
import { createLogger } from "@ai-learning-hub/logging";
import {
  getItem,
  putItem,
  updateItem,
  queryItems,
  type TableConfig,
} from "./helpers.js";

export const INVITE_CODES_TABLE_CONFIG: TableConfig = {
  tableName:
    process.env.INVITE_CODES_TABLE_NAME ?? "ai-learning-hub-invite-codes",
  partitionKey: "PK",
  sortKey: "SK",
};

/**
 * Invite code item stored in the invite-codes table.
 * PK: CODE#<code>, SK: META
 */
export interface InviteCodeItem extends Record<string, unknown> {
  PK: string;
  SK: string;
  code: string;
  generatedBy: string;
  generatedAt: string;
  redeemedBy?: string;
  redeemedAt?: string;
  expiresAt?: string;
  isRevoked?: boolean;
}

/**
 * Get an invite code by its value.
 * Returns null if the code does not exist.
 */
export async function getInviteCode(
  client: DynamoDBDocumentClient,
  code: string
): Promise<InviteCodeItem | null> {
  const logger = createLogger();

  return getItem<InviteCodeItem>(
    client,
    INVITE_CODES_TABLE_CONFIG,
    { PK: `CODE#${code}`, SK: "META" },
    logger
  );
}

/**
 * Redeem an invite code using conditional update.
 * Uses ConditionExpression to prevent double-redemption (atomic).
 *
 * @throws AppError NOT_FOUND if code doesn't exist or is already redeemed/revoked/expired
 */
export async function redeemInviteCode(
  client: DynamoDBDocumentClient,
  code: string,
  redeemedBy: string
): Promise<InviteCodeItem> {
  const logger = createLogger({ userId: redeemedBy });
  const now = new Date().toISOString();

  const result = await updateItem<InviteCodeItem>(
    client,
    INVITE_CODES_TABLE_CONFIG,
    {
      key: { PK: `CODE#${code}`, SK: "META" },
      updateExpression:
        "SET redeemedBy = :redeemedBy, redeemedAt = :redeemedAt",
      expressionAttributeValues: {
        ":redeemedBy": redeemedBy,
        ":redeemedAt": now,
        ":false": false,
      },
      conditionExpression:
        "attribute_exists(PK) AND attribute_not_exists(redeemedBy) AND (attribute_not_exists(isRevoked) OR isRevoked = :false)",
      returnValues: "ALL_NEW",
    },
    logger
  );

  if (!result) {
    throw new AppError(
      ErrorCode.INTERNAL_ERROR,
      "Failed to redeem invite code"
    );
  }

  logger.info("Invite code redeemed", { code: code.slice(0, 4) + "***" });
  return result;
}

const ALPHANUMERIC =
  "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";

/**
 * Generate a strictly alphanumeric code of the given length.
 * Uses crypto.randomBytes for secure randomness.
 */
function generateAlphanumericCode(length: number = 16): string {
  const bytes = randomBytes(length);
  return Array.from(bytes, (b) => ALPHANUMERIC[b % ALPHANUMERIC.length]).join(
    ""
  );
}

/**
 * Create an invite code in the invite-codes table.
 * Generates a 16-char alphanumeric code with 7-day expiry.
 * Retries once on collision (attribute_not_exists condition failure).
 *
 * @throws AppError INTERNAL_ERROR if code generation fails after retry
 */
export async function createInviteCode(
  client: DynamoDBDocumentClient,
  userId: string,
  expiresInHours: number = 7 * 24
): Promise<{ code: string; generatedAt: string; expiresAt: string }> {
  const logger = createLogger({ userId });
  const maxAttempts = 2;

  for (let attempt = 0; attempt < maxAttempts; attempt++) {
    const code = generateAlphanumericCode(16);
    const now = new Date();
    const generatedAt = now.toISOString();
    const expiresAt = new Date(
      now.getTime() + expiresInHours * 60 * 60 * 1000
    ).toISOString();

    const item: InviteCodeItem = {
      PK: `CODE#${code}`,
      SK: "META",
      code,
      generatedBy: userId,
      generatedAt,
      expiresAt,
    };

    try {
      await putItem(
        client,
        INVITE_CODES_TABLE_CONFIG,
        item,
        { conditionExpression: "attribute_not_exists(PK)" },
        logger
      );

      logger.info("Invite code created", { code: code.slice(0, 4) + "***" });
      return { code, generatedAt, expiresAt };
    } catch (error) {
      if (
        AppError.isAppError(error) &&
        error.code === ErrorCode.CONFLICT &&
        attempt < maxAttempts - 1
      ) {
        logger.warn("Invite code collision, retrying", { attempt });
        continue;
      }
      if (AppError.isAppError(error) && error.code === ErrorCode.CONFLICT) {
        throw new AppError(
          ErrorCode.INTERNAL_ERROR,
          "Failed to generate invite code"
        );
      }
      throw error;
    }
  }

  throw new AppError(
    ErrorCode.INTERNAL_ERROR,
    "Failed to generate invite code"
  );
}

/**
 * List invite codes generated by a specific user.
 * Queries the generatedBy-index GSI and sorts results in-memory
 * by generatedAt descending (newest first), since the GSI has no sort key.
 */
export async function listInviteCodesByUser(
  client: DynamoDBDocumentClient,
  userId: string,
  limit?: number,
  cursor?: string
): Promise<PaginatedResponse<InviteCodeItem>> {
  const logger = createLogger({ userId });

  const result = await queryItems<InviteCodeItem>(
    client,
    INVITE_CODES_TABLE_CONFIG,
    {
      keyConditionExpression: "generatedBy = :userId",
      expressionAttributeValues: { ":userId": userId },
      indexName: "generatedBy-index",
      limit,
      cursor,
    },
    logger
  );

  // Sort in-memory by generatedAt descending (newest first)
  // GSI has no sort key, so DynamoDB returns items in arbitrary order
  result.items.sort(
    (a, b) =>
      new Date(b.generatedAt).getTime() - new Date(a.generatedAt).getTime()
  );

  return result;
}

/**
 * Public representation of an invite code (strips PK/SK, masks redeemed codes).
 */
export interface PublicInviteCodeItem {
  code: string;
  status: "active" | "redeemed" | "expired" | "revoked";
  generatedAt: string;
  expiresAt?: string;
  redeemedAt?: string;
}

/**
 * Convert an InviteCodeItem to its public representation.
 * Status priority: revoked > redeemed > expired > active.
 * Masks code (first 4 chars + '****') if redeemed.
 */
export function toPublicInviteCode(item: InviteCodeItem): PublicInviteCodeItem {
  const now = new Date();

  let status: PublicInviteCodeItem["status"];
  if (item.isRevoked) status = "revoked";
  else if (item.redeemedBy) status = "redeemed";
  else if (item.expiresAt && new Date(item.expiresAt) < now) status = "expired";
  else status = "active";

  return {
    code: item.redeemedBy ? item.code.slice(0, 4) + "****" : item.code,
    status,
    generatedAt: item.generatedAt,
    expiresAt: item.expiresAt,
    redeemedAt: item.redeemedAt,
  };
}
