---
id: "2.1-D10"
title: "Add JWT Fallback to API Key Authorizer"
status: ready-for-dev
depends_on: ["2.1-D8"]
touches:
  - backend/functions/api-key-authorizer/handler.ts
  - backend/functions/api-key-authorizer/handler.test.ts
  - infra/lib/stacks/auth/auth.stack.ts
  - infra/test/stacks/auth/auth.stack.test.ts
risk: medium
---

# Story 2.1.D10: Add JWT Fallback to API Key Authorizer

## Story

As a frontend user authenticating with a Clerk JWT,
I want the API Key authorizer Lambda to validate my JWT when no `x-api-key` header is present,
so that JWT-only clients can access routes configured with the "jwt-or-apikey" authorizer pattern.

## Context & Motivation

The smoke test (D6/D8) revealed that all "jwt-or-apikey" routes (`GET /users/me`, `POST /users/api-keys`, etc.) return HTTP 401 when called with only a JWT — the API Key authorizer Lambda immediately throws `Unauthorized` when the `x-api-key` header is missing, without attempting JWT validation.

**Architecture context:**

- API Gateway has two authorizers: a TOKEN-type `jwt-authorizer` and a REQUEST-type `api-key-authorizer`
- Per ADR-013, most routes use the `api-key-authorizer` because they need to accept **both** JWT and API Key authentication
- Only `POST /auth/validate-invite` uses the `jwt-authorizer` (JWT-only route)
- The REQUEST-type authorizer receives **all** request headers (including `Authorization`), making it the correct place to implement dual-auth fallback
- The TOKEN-type authorizer only receives the `authorizationToken` value — it cannot see `x-api-key`

**Current state of the `api-key-authorizer` handler:**

```typescript
// Line 51-54 — immediately throws when x-api-key is missing
if (!apiKey) {
  logger.warn("Missing x-api-key header");
  throw new Error("Unauthorized");
}
```

**Route-to-authorizer mapping (from `auth-routes.stack.ts`):**

| Route | Authorizer | Auth pattern |
|---|---|---|
| `POST /auth/validate-invite` | `jwtAuthorizer` | JWT only |
| `GET/PATCH /users/me` | `apiKeyAuthorizer` | JWT or API Key |
| `POST/GET /users/api-keys` | `apiKeyAuthorizer` | JWT or API Key |
| `DELETE /users/api-keys/{id}` | `apiKeyAuthorizer` | JWT or API Key |
| `POST/GET /users/invite-codes` | `apiKeyAuthorizer` | JWT or API Key |

The fix adds JWT validation as a fallback path in the API Key authorizer handler, mirrors the jwt-authorizer's Clerk verification logic, and updates CDK infrastructure to grant the necessary permissions and environment variables.

## Acceptance Criteria

### Lambda Code Changes

1. **AC1** — Given a request to a "jwt-or-apikey" route with an `Authorization: Bearer <token>` header and **no** `x-api-key` header, when the API Key authorizer Lambda is invoked, then it validates the JWT using `@clerk/backend verifyToken`, performs profile lookup (with create-on-first-auth), and returns an Allow policy with context `{ userId, role, authMethod: "jwt" }`.

2. **AC2** — Given a request with **both** `x-api-key` and `Authorization: Bearer` headers, when the API Key authorizer Lambda is invoked, then API key validation takes priority (existing behavior unchanged).

3. **AC3** — Given a request with an expired or invalid JWT and **no** `x-api-key` header, when the API Key authorizer Lambda is invoked, then it throws `Error("Unauthorized")` resulting in a 401 response.

4. **AC4** — Given a JWT for a user whose `publicMetadata.inviteValidated` is not `true` and **no** `x-api-key` header, when the API Key authorizer Lambda is invoked, then it returns a Deny policy with `errorCode: "INVITE_REQUIRED"`.

5. **AC5** — Given a JWT for a suspended user and **no** `x-api-key` header, when the API Key authorizer Lambda is invoked, then it returns a Deny policy with `errorCode: "SUSPENDED_ACCOUNT"`.

6. **AC6** — Given a JWT for a first-time user (no existing profile) and **no** `x-api-key` header, when the API Key authorizer Lambda is invoked, then it calls `ensureProfile()` to create the user profile (create-on-first-auth), then returns an Allow policy.

### Infrastructure Changes

7. **AC7** — Given the `AuthStack` CDK definition, when it is synthesized, then the API Key authorizer Lambda has:
   - `CLERK_SECRET_KEY_PARAM` environment variable set
   - `ssm:GetParameter` IAM permission for the Clerk secret key SSM parameter
   - `dynamodb:PutItem` IAM permission on the users table (for `ensureProfile`)

### Test Coverage (TDD)

8. **AC8** — Given the API Key authorizer unit tests, when they run, then new tests cover:
   - JWT fallback: valid JWT with no API key → Allow with `authMethod: "jwt"` (AC1)
   - API key priority: both headers present → API key path used (AC2)
   - JWT fallback: invalid/expired JWT → Unauthorized (AC3)
   - JWT fallback: invite not validated → Deny INVITE_REQUIRED (AC4)
   - JWT fallback: suspended account → Deny SUSPENDED_ACCOUNT (AC5)
   - JWT fallback: create-on-first-auth → ensureProfile called (AC6)
   - Neither header present → Unauthorized
   - JWT fallback: context shape matches jwt-authorizer output

9. **AC9** — Given the `AuthStack` unit tests, when they run, then assertions verify the API Key authorizer Lambda has `CLERK_SECRET_KEY_PARAM` env var and `ssm:GetParameter` permission.

### Gate

10. **AC10** — All existing tests pass (`npm test`), CDK synth passes, no lint errors, and no regressions.

11. **AC11** — After deployment, re-run the smoke test (`npm run smoke-test`) with a fresh Clerk JWT. AC1 (`Valid JWT → GET /users/me → 200`) must pass.

## Tasks / Subtasks

### Phase 1: Write Tests First (TDD Red)

- [ ] **Task 1: Add JWT fallback tests to api-key-authorizer** (AC: #8)
  - [ ] 1.1 Add test helpers: mock `verifyToken` from `@clerk/backend`, mock `getClerkSecretKey` from `@ai-learning-hub/middleware`, mock `ensureProfile` from `@ai-learning-hub/db`
  - [ ] 1.2 Add `describe("JWT Fallback (no x-api-key)")` block with these tests:
    - Valid JWT, no API key → returns Allow with `{ userId: clerkId, role, authMethod: "jwt" }` (AC1)
    - Valid JWT, invite not validated → returns Deny INVITE_REQUIRED (AC4)
    - Valid JWT, suspended account → returns Deny SUSPENDED_ACCOUNT (AC5)
    - Valid JWT, first-time user → calls ensureProfile, returns Allow (AC6)
    - Expired/invalid JWT, no API key → throws Unauthorized (AC3)
    - No Authorization header and no API key → throws Unauthorized
  - [ ] 1.3 Add `describe("Auth method priority")` block:
    - Both x-api-key and Authorization present → uses API key path (AC2)
  - [ ] 1.4 Add `describe("JWT fallback context shape")` block:
    - JWT path context does NOT include `isApiKey`, `apiKeyId`, `scopes`
    - JWT path context includes `authMethod: "jwt"` (not "api-key")
  - [ ] 1.5 Verify all new tests FAIL (red phase) before implementing

### Phase 2: Implement Handler Changes (TDD Green)

- [ ] **Task 2: Add JWT validation fallback to handler** (AC: #1, #2, #3, #4, #5, #6)
  - [ ] 2.1 Add imports: `verifyToken` from `@clerk/backend`, `ensureProfile` and `PublicMetadata` from `@ai-learning-hub/db`, `getClerkSecretKey` from `@ai-learning-hub/middleware`
  - [ ] 2.2 When `x-api-key` is missing, extract JWT from `Authorization: Bearer <token>` header (case-insensitive header lookup, strip `Bearer ` prefix)
  - [ ] 2.3 If JWT is present, validate via `verifyToken()` with Clerk secret key from SSM
  - [ ] 2.4 Mirror jwt-authorizer logic: check inviteValidated → getProfile → ensureProfile if missing → check suspension → return Allow with `authMethod: "jwt"`
  - [ ] 2.5 If both JWT validation fails and no API key → throw Unauthorized
  - [ ] 2.6 If neither header is present → throw Unauthorized
  - [ ] 2.7 Verify all new tests PASS (green phase)

### Phase 3: Infrastructure Changes

- [ ] **Task 3: Update AuthStack CDK for API Key authorizer** (AC: #7, #9)
  - [ ] 3.1 Add `CLERK_SECRET_KEY_PARAM` to `apiKeyAuthorizerFunction` environment variables
  - [ ] 3.2 Add `ssm:GetParameter` IAM permission for the Clerk secret key SSM parameter ARN
  - [ ] 3.3 Add `dynamodb:PutItem` to the existing IAM policy statement (needed for `ensureProfile`)
  - [ ] 3.4 Update `auth.stack.test.ts`: assert `apiKeyAuthorizerFunction` has `CLERK_SECRET_KEY_PARAM` env var
  - [ ] 3.5 Update `auth.stack.test.ts`: assert the Lambdas-with-CLERK_SECRET_KEY_PARAM count increases (currently jwt-authorizer + validate-invite = 2; now add api-key-authorizer = 3)

### Phase 4: Verify Gate

- [ ] **Task 4: Run all tests and validate** (AC: #10)
  - [ ] 4.1 Run `npm test` across all workspaces — all tests must pass
  - [ ] 4.2 Run `cd infra && npx cdk synth` — verify the synthesized template
  - [ ] 4.3 Run `npm run lint` — no lint errors

### Phase 5: Deploy and Smoke Test

- [ ] **Task 5: Deploy and validate with smoke test** (AC: #11)
  - [ ] 5.1 Run `npm run build && npx cdk deploy AiLearningHubAuth` to update the Auth stack
  - [ ] 5.2 Run `aws apigateway create-deployment --rest-api-id <id> --stage-name dev` to push changes to dev stage
  - [ ] 5.3 Get a fresh Clerk JWT from the frontend (sign in at localhost:5173, click "Copy JWT")
  - [ ] 5.4 Run `npm run smoke-test` — AC1 (valid JWT → GET /users/me → 200) must pass
  - [ ] 5.5 Verify AC2 (malformed JWT → 401), AC3 (no auth → 401) still pass
  - [ ] 5.6 Verify API key scenarios (AC5, AC13) work end-to-end

## Dev Notes

### Handler Implementation Pattern

The handler flow should be:

```
1. Extract x-api-key header (case-insensitive)
2. If x-api-key present → existing API key validation path (unchanged)
3. If x-api-key absent:
   a. Extract Authorization header (case-insensitive)
   b. Strip "Bearer " prefix
   c. If token present → JWT validation path (new):
      i.   verifyToken() via @clerk/backend
      ii.  Check publicMetadata.inviteValidated
      iii. getProfile() → ensureProfile() if missing → getProfile() again
      iv.  Check suspension
      v.   Return Allow with { userId: clerkId, role, authMethod: "jwt" }
   d. If no token → throw Unauthorized
4. Catch-all: throw Unauthorized
```

### Infrastructure Delta

The API Key authorizer Lambda currently has:
- **Env vars**: `USERS_TABLE_NAME`, `INVITE_CODES_TABLE_NAME`
- **IAM**: `dynamodb:GetItem`, `dynamodb:Query`, `dynamodb:UpdateItem` on users table + indexes

After this story it needs:
- **Env vars**: + `CLERK_SECRET_KEY_PARAM`
- **IAM**: + `ssm:GetParameter` on Clerk SSM parameter, + `dynamodb:PutItem` on users table

### Key Shared Utilities

| Utility | Package | Used for |
|---|---|---|
| `verifyToken(token, { secretKey })` | `@clerk/backend` | JWT signature + expiry validation |
| `getClerkSecretKey()` | `@ai-learning-hub/middleware` | Fetch Clerk secret from SSM (cached) |
| `getProfile(client, userId, logger)` | `@ai-learning-hub/db` | Read user profile from DynamoDB |
| `ensureProfile(client, clerkId, metadata, logger)` | `@ai-learning-hub/db` | Create-on-first-auth |
| `generatePolicy(effect)` | `@ai-learning-hub/middleware` | IAM policy document for authorizer response |
| `deny(principalId, errorCode)` | `@ai-learning-hub/middleware` | Deny response with error code in context |

### Context Shape Differences

**API Key path (existing):**
```json
{ "userId": "...", "role": "user", "authMethod": "api-key", "isApiKey": "true", "apiKeyId": "...", "scopes": "[\"keys:manage\",\"captures:write\"]" }
```

**JWT path (new):**
```json
{ "userId": "user_clerkId", "role": "user", "authMethod": "jwt" }
```

Downstream handler code uses `extractAuthContext()` from `@ai-learning-hub/middleware` which already handles both shapes — no downstream changes needed.

### Architecture Constraints

- Do NOT modify the jwt-authorizer handler — it remains the dedicated JWT-only authorizer
- Do NOT change the route-to-authorizer mapping in `auth-routes.stack.ts`
- Do NOT change the authorizer types (TOKEN vs REQUEST) in `api-gateway.stack.ts`
- The fix is contained to the api-key-authorizer handler + its CDK definition + tests
- Reuse existing shared utilities — do not duplicate JWT validation logic

### Testing Strategy

Use **TDD red-green-refactor**:
1. Write all new tests first (they will fail — "red")
2. Implement the handler changes (tests pass — "green")
3. Refactor if needed (extract shared helpers, clean up)

Mock strategy (matching existing test patterns):
- Mock `@clerk/backend` → `verifyToken`
- Mock `@ai-learning-hub/middleware` → `getClerkSecretKey`
- Mock `@ai-learning-hub/db` → `getProfile`, `ensureProfile`, `getApiKeyByHash`, `updateApiKeyLastUsed`
- Use existing test fixtures for events, profiles, and API key items

### Git Workflow

**Branch naming:** `story-2-1-d10-api-key-authorizer-jwt-fallback`
**Commit pattern:** `feat: add JWT fallback to API Key authorizer (Story 2.1-D10)`

### References

- [Source: backend/functions/jwt-authorizer/handler.ts] — JWT validation reference implementation
- [Source: backend/functions/api-key-authorizer/handler.ts] — Handler to modify
- [Source: infra/lib/stacks/auth/auth.stack.ts] — CDK definition to update
- [Source: infra/lib/stacks/api/auth-routes.stack.ts] — Route-to-authorizer mapping (read-only)
- [ADR-013] — Clerk Authentication Provider design decisions

## Dev Agent Record

### Agent Model Used

{{agent_model_name_version}}

### Debug Log References

### Completion Notes List

### File List
