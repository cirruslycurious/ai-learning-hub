---
id: "2.1-D9"
title: "Foundations Hardening — Adversarial Review Remediation"
status: ready-for-dev
depends_on: ["2.1-D5", "2.1-D7", "2.1-D8"]
touches:
  - infra/test/architecture-enforcement
  - infra/test/helpers
  - infra/test/stacks/auth
  - infra/test/stacks/api
  - backend/test/import-enforcement.test.ts
  - backend/test/quality-gate-self-test.test.ts
  - backend/test
  - backend/shared/db/src
  - backend/shared/middleware/src/wrapper.ts
  - backend/shared/middleware/test/wrapper.test.ts
  - backend/test-utils/mock-wrapper.ts
  - backend/functions/api-key-authorizer/handler.ts
  - backend/functions/api-key-authorizer/handler.test.ts
risk: medium
---

# Story 2.1.D9: Foundations Hardening — Adversarial Review Remediation

## Story

As a developer building Epics 3–11 on top of the foundations laid by Epics 1, 2, and 2.1,
I want the structural gaps identified by two independent adversarial architecture reviews (Opus, GPT-5.2) closed — covering reverse-direction route enforcement, wrapHandler usage scanning, auth-type consistency, self-discovering quality gates, dev-auth-bypass protection, import hardening, and ADR-008 pass-through policy,
so that the architecture enforcement suite catches real drift as the route/handler count grows from 5 to 50+, and future epics build on genuinely robust foundations rather than coincidentally aligned ones.

## Context & Motivation

Two independent adversarial reviews were conducted against the post-D7/D8 codebase (Opus and GPT-5.2). Both reviews scored the foundations at 7/10 and identified the **same top-priority gaps**:

1. **Route registry is validated in one direction only** — T2 checks registry→CDK but not CDK→registry. A "mystery route" added to a route stack without a registry entry passes all tests. Both reviews rank this as the #1 hardening priority.
2. **No enforcement that handlers use `wrapHandler`** — A new handler can export a raw Lambda function, bypassing ADR-008, auth, and logging. Both reviews flag this.
3. **`ALLOW_DEV_AUTH_HEADER` can reach production** — No CDK-level test prevents this env var from being set on Lambda functions. Both reviews call it a security footgun.
4. **Quality gate has a static config list** — `VITEST_CONFIG_PATHS` is hardcoded; new packages silently skip coverage enforcement.
5. **`jwt-or-apikey` routes don't actually accept JWTs** — The API key authorizer rejects missing `x-api-key` without attempting JWT validation. Routes claim JWT fallback but it doesn't exist.
6. **wrapHandler options can contradict the route registry** — A handler can set `requireAuth: false` for a route the registry declares as `jwt`, with no test catching the mismatch.
7. **Import enforcement misses dynamic `import()` and console destructuring** — Easy bypass paths exist.
8. **ADR-008 has no policy for pass-through responses** — A handler returning a raw `APIGatewayProxyResult` with non-ADR-008 error body bypasses `wrapHandler`'s normalization.

Additionally, D7 code reviews deferred several cleanup items that should be resolved:

- `requireEnv` function duplicated in two DB files
- Mock-wrapper lacks protected header enforcement (diverges from production)
- Mock-wrapper omits error `details` field (diverges from production)
- Scope enforcement tests use string literal casts instead of `ErrorCode` enum members

**Review sources:**
- `backend/shared/types/src/foundations_review_opus.md` (Opus — 8 hardening items, 12 adversarial tests)
- `backend/shared/types/src/foundations_review_gpt52.md` (GPT-5.2 — 8 hardening items, 10 adversarial tests)
- `docs/progress/story-2.1-D7-review-findings-round-1.md` (5 deferred items)
- `docs/progress/story-2.1-D7-review-findings-round-2.md` (4 deferred items)

## Acceptance Criteria

### Group A: Architecture Enforcement Completeness

1. **AC1 — Reverse-direction route test (no mystery routes)** — Given the CDK routes template is synthesized, when the test runs, then every non-OPTIONS `AWS::ApiGateway::Method` has a corresponding entry in `ROUTE_REGISTRY` (matching path + HTTP method). If a route exists in CDK but not in the registry, the test fails with: `"Route {path} {method} exists in CDK but has no ROUTE_REGISTRY entry"`.

2. **AC2 — Enforce wrapHandler usage in all API handlers** — Given all `handler.ts` files in `backend/functions/*/` (excluding `*-authorizer` directories), when a scan test runs, then every file exports `handler` matching the pattern `wrapHandler(`. If a handler bypasses `wrapHandler`, the test fails with: `"Handler {file} does not use wrapHandler — ADR-008 compliance requires it"`.

3. **AC3 — Self-discovering vitest config scan** — Given new shared packages may be added in future epics, when the quality gate self-test runs, then it discovers vitest config files via glob scan (`backend/shared/*/vitest.config.ts`, `backend/vitest.config.ts`, `infra/vitest.config.ts`) instead of a static list. A new package with missing or low thresholds fails the test without requiring manual list updates.

### Group B: Auth Foundation Correctness

4. **AC4 — Fix jwt-or-apikey semantic mismatch** — Given routes with `authType: "jwt-or-apikey"` in the route registry, when a request arrives with only an `Authorization: Bearer <jwt>` header (no `x-api-key`), then the API key authorizer Lambda attempts JWT validation as a fallback and returns an Allow policy with `context.authMethod = "jwt"`. The authorizer only rejects when **both** auth methods fail.

5. **AC5 — JWT fallback test coverage** — Given the updated API key authorizer handler, when unit tests run, then at least three new scenarios pass: (a) valid JWT without x-api-key → Allow with `authMethod: "jwt"`, (b) valid API key without Authorization header → Allow with `authMethod: "api-key"`, (c) both headers missing → Deny.

6. **AC6 — wrapHandler options vs registry auth-type consistency test** — Given each handler's `wrapHandler` options declare `requireAuth` and optionally `requiredScope`, when a consistency test runs, then for every `ROUTE_REGISTRY` entry with `authType` != `"public"`, the corresponding handler file contains `requireAuth: true` in its `wrapHandler` call. If a handler has `requireAuth: false` (or missing) for a route the registry requires auth on, the test fails with: `"Handler {handlerRef} has requireAuth: false but registry requires {authType}"`.

7. **AC7 — ALLOW_DEV_AUTH_HEADER CDK environment audit** — Given all Lambda functions in `AuthStack` and any handler stacks, when a CDK template test runs, then no `AWS::Lambda::Function` resource has `ALLOW_DEV_AUTH_HEADER` in its `Environment.Variables`. The test fails with: `"Lambda {logicalId} has ALLOW_DEV_AUTH_HEADER set — this is a production auth bypass risk"`.

### Group C: Import & Contract Hardening

8. **AC8 — Harden import enforcement against dynamic imports** — Given the T6 import enforcement test scans handler files, when it runs, then it also detects: (a) dynamic `import("@aws-sdk/...")` calls, and (b) console destructuring patterns (e.g., `const { log } = console`). Both patterns produce clear violation messages.

9. **AC9 — ADR-008 pass-through response policy test** — Given `wrapHandler` in `backend/shared/middleware/src/wrapper.ts` currently passes through `APIGatewayProxyResult` responses without normalization, when a handler returns a non-2xx `APIGatewayProxyResult` with a non-ADR-008 body (e.g., `{ statusCode: 400, body: "bad" }`), then `wrapHandler` normalizes the error body to ADR-008 format by wrapping it as `{ error: { code: "INTERNAL_ERROR", message: "...", requestId } }`. A unit test verifies this normalization.

### Group D: D7 Deferred Cleanup

10. **AC10 — Extract `requireEnv` to shared DB utility** — Given the `requireEnv` function is duplicated in `backend/shared/db/src/users.ts` and `backend/shared/db/src/invite-codes.ts`, when the refactor is complete, then a single `requireEnv` function exists in `backend/shared/db/src/helpers.ts` (or `config.ts`) and both files import it. All existing tests pass.

11. **AC11 — Mock-wrapper production parity (protected headers)** — Given the production `createErrorResponse` blocks `Content-Type` and `X-Request-Id` overrides via `PROTECTED_HEADERS`, when the mock-wrapper in `backend/test-utils/mock-wrapper.ts` processes `responseHeaders`, then it applies the same protection. A test verifies that `responseHeaders: { "Content-Type": "text/html" }` is stripped in the mock, matching production behavior.

12. **AC12 — Mock-wrapper production parity (error details)** — Given the production `createErrorResponse` includes `error.details` (minus `responseHeaders`) in the response body, when the mock-wrapper serializes error responses, then it includes `details` (minus `responseHeaders`) in the body to match production. A test verifies that `details: { requiredScope: "keys:manage" }` appears in the mock response body.

13. **AC13 — Scope tests use ErrorCode enum** — Given the scope enforcement tests in `api-keys/handler.test.ts` and `invite-codes/handler.test.ts` use `"SCOPE_INSUFFICIENT" as ErrorCode`, when the refactor is complete, then they use `ErrorCode.SCOPE_INSUFFICIENT` directly (type-safe, no cast).

### Group E: Gate

14. **AC14** — All existing tests pass (`npm test`), CDK synth passes, no lint errors, no regressions in coverage thresholds, and the smoke test (`npm run smoke-test`) validates JWT fallback on `jwt-or-apikey` routes after deployment.

## Tasks / Subtasks

- [ ] **Task 1: Add reverse-direction route test** (AC: #1)
  - [ ] 1.1 In `infra/test/architecture-enforcement/route-completeness.test.ts`, add a new `describe("AC6b: No unregistered routes in CDK")` block
  - [ ] 1.2 Iterate all `AWS::ApiGateway::Method` resources in the routes template, resolve each method's resource path (using the existing `getResourcePaths` helper), filter out OPTIONS methods
  - [ ] 1.3 For each non-OPTIONS method, assert a matching `ROUTE_REGISTRY` entry exists (path + HTTP method). Fail with a clear message identifying unregistered routes
  - [ ] 1.4 Add a negative test: create a fixture route stack that adds an extra `/debug` route not in the registry, assert the new test catches it

- [ ] **Task 2: Enforce wrapHandler usage in all API handlers** (AC: #2)
  - [ ] 2.1 In `backend/test/import-enforcement.test.ts`, add a new `describe("T6b: wrapHandler usage enforcement")` block
  - [ ] 2.2 Scan all `handler.ts` files in `backend/functions/*/` (excluding `*-authorizer` directories)
  - [ ] 2.3 For each file, assert the content matches pattern `export\s+(const|let)\s+handler\s*=\s*wrapHandler\(` (regex)
  - [ ] 2.4 Add a negative test with a fixture file that exports a raw handler, verify the scan detects it

- [ ] **Task 3: Make VITEST_CONFIG_PATHS self-discovering** (AC: #3)
  - [ ] 3.1 In `backend/test/quality-gate-self-test.test.ts`, replace the static `VITEST_CONFIG_PATHS` array with a glob scan using `fs.readdirSync` / `path.resolve`
  - [ ] 3.2 Scan patterns: `backend/shared/*/vitest.config.ts`, `backend/vitest.config.ts`, `infra/vitest.config.ts`
  - [ ] 3.3 Assert the discovered list is non-empty (at least 7 configs expected)
  - [ ] 3.4 Verify the test still correctly enforces >= 80% thresholds on all discovered configs

- [ ] **Task 4: Fix jwt-or-apikey authorizer to support JWT fallback** (AC: #4, #5)
  - [ ] 4.1 In `backend/functions/api-key-authorizer/handler.ts`, when `x-api-key` is missing, check for `Authorization: Bearer <token>` header
  - [ ] 4.2 If a Bearer token is present, verify it using the same Clerk JWKS verification logic as the JWT authorizer (extract shared verification into a utility if needed, or import from `@ai-learning-hub/middleware`)
  - [ ] 4.3 On successful JWT verification, return an Allow policy with `context: { userId, roles, authMethod: "jwt", isApiKey: "false" }`
  - [ ] 4.4 Only reject (throw Unauthorized) when **both** x-api-key is missing/invalid **and** JWT is missing/invalid
  - [ ] 4.5 Add unit tests: (a) valid JWT without x-api-key → Allow + `authMethod: "jwt"`, (b) valid API key without Authorization → Allow + `authMethod: "api-key"` (existing), (c) both missing → Deny, (d) invalid JWT + missing API key → Deny, (e) valid JWT + valid API key → prefer API key (existing behavior)

- [ ] **Task 5: Add wrapHandler options vs registry auth-type consistency test** (AC: #6)
  - [ ] 5.1 Create `backend/test/auth-consistency.test.ts`
  - [ ] 5.2 For each entry in `ROUTE_REGISTRY`, determine the corresponding handler file from `handlerRef` (build a `handlerRef → file path` mapping)
  - [ ] 5.3 Read each handler file content and parse the `wrapHandler(...)` options block
  - [ ] 5.4 Assert that routes with `authType` != `"public"` have `requireAuth: true` in their `wrapHandler` call
  - [ ] 5.5 Assert that routes with `authType` containing scope requirements have `requiredScope` present (if applicable)

- [ ] **Task 6: Add ALLOW_DEV_AUTH_HEADER CDK environment audit** (AC: #7)
  - [ ] 6.1 In `infra/test/stacks/auth/auth.stack.test.ts` (or a new file in `infra/test/architecture-enforcement/`), add a test that synthesizes `AuthStack`
  - [ ] 6.2 Find all `AWS::Lambda::Function` resources in the template
  - [ ] 6.3 For each function, inspect `Properties.Environment.Variables` and assert `ALLOW_DEV_AUTH_HEADER` is not present
  - [ ] 6.4 Add a comment documenting that if the env var is needed for a dev stage, it must be gated behind a CDK context flag and this test must be updated to allow it only for `stage === "dev"`

- [ ] **Task 7: Harden import enforcement** (AC: #8)
  - [ ] 7.1 In `backend/test/import-enforcement.test.ts`, add a scan for dynamic import patterns: `import\s*\(\s*["']@aws-sdk/` and `import\s*\(\s*["']aws-sdk`
  - [ ] 7.2 Add a scan for console destructuring: `const\s*\{[^}]*\}\s*=\s*console` and `=\s*console\.\w+` (aliasing)
  - [ ] 7.3 Add negative tests for both patterns to verify detection

- [ ] **Task 8: Add ADR-008 pass-through response normalization** (AC: #9)
  - [ ] 8.1 In `backend/shared/middleware/src/wrapper.ts`, find the `isApiGatewayResult` pass-through path
  - [ ] 8.2 For non-2xx pass-through responses (statusCode >= 400), attempt to parse the body; if it doesn't conform to ADR-008 shape (`{ error: { code, message, requestId } }`), wrap it as `{ error: { code: "INTERNAL_ERROR", message: <original body or "Unknown error">, requestId } }` and log a warning
  - [ ] 8.3 Add unit tests in `backend/shared/middleware/test/wrapper.test.ts`: (a) non-2xx with non-JSON body → normalized, (b) non-2xx with ADR-008 body → passed through as-is, (c) 2xx pass-through → unchanged

- [ ] **Task 9: Extract requireEnv to shared utility** (AC: #10)
  - [ ] 9.1 Create or extend `backend/shared/db/src/helpers.ts` to export `requireEnv(name: string, testFallback?: string): string`
  - [ ] 9.2 Update `backend/shared/db/src/users.ts` to import `requireEnv` from helpers
  - [ ] 9.3 Update `backend/shared/db/src/invite-codes.ts` to import `requireEnv` from helpers
  - [ ] 9.4 Add a unit test for `requireEnv` in `backend/shared/db/test/helpers.test.ts`: (a) env var set → returns value, (b) env var missing + NODE_ENV=test → returns fallback, (c) env var missing + NODE_ENV=production → throws

- [ ] **Task 10: Mock-wrapper production parity** (AC: #11, #12, #13)
  - [ ] 10.1 In `backend/test-utils/mock-wrapper.ts`, add `PROTECTED_HEADERS` filtering to `responseHeaders` handling (matching production `error-handler.ts`)
  - [ ] 10.2 Add `details` field (minus `responseHeaders`) to the mock error body serialization
  - [ ] 10.3 In `backend/test-utils/mock-wrapper.test.ts`, add tests for: (a) protected header stripping, (b) details field appearing in body, (c) responseHeaders stripped from body details
  - [ ] 10.4 In `backend/functions/api-keys/handler.test.ts`, replace `"SCOPE_INSUFFICIENT" as ErrorCode` with `ErrorCode.SCOPE_INSUFFICIENT`
  - [ ] 10.5 In `backend/functions/invite-codes/handler.test.ts`, replace `"SCOPE_INSUFFICIENT" as ErrorCode` with `ErrorCode.SCOPE_INSUFFICIENT`

- [ ] **Task 11: Verify gate** (AC: #14)
  - [ ] 11.1 Run `npm test` across all workspaces — all tests must pass
  - [ ] 11.2 Run `npx tsc --noEmit` across all workspaces — no type errors
  - [ ] 11.3 Run `npm run lint` — no lint errors
  - [ ] 11.4 Run `cd infra && cdk synth` — must complete without errors
  - [ ] 11.5 Verify coverage thresholds still met (80%+ across all packages)
  - [ ] 11.6 After deployment: run `npm run smoke-test` — validate JWT-only requests to `jwt-or-apikey` routes now succeed (AC4 runtime validation)

## Dev Notes

### Task Ordering Recommendation

**Track 1 (architecture enforcement — independent):**
Tasks 1, 2, 3, 5, 6, 7 — All add new test assertions. No production code changes. Can be done in any order.

**Track 2 (auth fix — requires care):**
Task 4 — Modifies authorizer handler behavior. Must be done before Task 11 gate. Requires shared JWT verification utility (check if `@ai-learning-hub/middleware` already exports Clerk JWT verification that can be reused).

**Track 3 (middleware hardening):**
Task 8 — Modifies `wrapHandler` behavior for non-2xx pass-through. Low risk but requires careful testing.

**Track 4 (cleanup):**
Tasks 9, 10 — Pure refactors, no behavior changes.

### JWT Verification Sharing (Task 4)

The JWT authorizer (`backend/functions/jwt-authorizer/handler.ts`) already has Clerk JWT verification logic. The API key authorizer needs the same logic for JWT fallback. Options:

1. **Extract shared verification utility** — Move JWT verification to `@ai-learning-hub/middleware` (e.g., `verifyClerkJwt(token, jwksUri, logger)`), import in both authorizers. This is architecturally cleaner.
2. **Inline in api-key-authorizer** — Copy the verification logic. Faster but violates DRY. Not recommended if both authorizers will evolve.

Recommended: Option 1. The shared verification function should handle JWKS fetching, signature verification, expiry checking, and returning claims.

### Reverse-Direction Route Test Pattern (Task 1)

```typescript
it("AC6b: no unregistered routes in CDK templates", () => {
  const methods = routesTemplate.findResources("AWS::ApiGateway::Method");
  const resourcePaths = getResourcePaths(routesTemplate);
  const unregistered: string[] = [];

  for (const [logicalId, method] of Object.entries(methods)) {
    const httpMethod = method.Properties?.HttpMethod;
    if (httpMethod === "OPTIONS") continue;

    const resourceId = method.Properties?.ResourceId?.Ref;
    const path = resourcePaths.get(resourceId);
    if (!path) continue;

    const registryMatch = ROUTE_REGISTRY.find(
      (r) => r.path === path && r.methods.includes(httpMethod)
    );
    if (!registryMatch) {
      unregistered.push(`${httpMethod} ${path}`);
    }
  }

  if (unregistered.length > 0) {
    expect.fail(
      `Routes exist in CDK but not in ROUTE_REGISTRY:\n${unregistered.map((r) => `  - ${r}`).join("\n")}`
    );
  }
});
```

### wrapHandler Enforcement Pattern (Task 2)

```typescript
const HANDLER_EXPORT_PATTERN = /export\s+(const|let)\s+handler\s*=\s*wrapHandler\s*\(/;
const AUTHORIZER_DIR_PATTERN = /-authorizer$/;

it("every API handler uses wrapHandler", () => {
  const handlerDirs = fs.readdirSync(functionsDir, { withFileTypes: true })
    .filter((d) => d.isDirectory() && !AUTHORIZER_DIR_PATTERN.test(d.name));

  const violations: string[] = [];
  for (const dir of handlerDirs) {
    const handlerPath = path.join(functionsDir, dir.name, "handler.ts");
    if (!fs.existsSync(handlerPath)) continue;
    const content = fs.readFileSync(handlerPath, "utf-8");
    if (!HANDLER_EXPORT_PATTERN.test(content)) {
      violations.push(handlerPath);
    }
  }

  if (violations.length > 0) {
    expect.fail(
      `Handlers bypass wrapHandler (ADR-008 non-compliant):\n${violations.join("\n")}`
    );
  }
});
```

### ALLOW_DEV_AUTH_HEADER Audit Pattern (Task 6)

```typescript
it("no Lambda has ALLOW_DEV_AUTH_HEADER in environment", () => {
  const functions = template.findResources("AWS::Lambda::Function");
  const violations: string[] = [];

  for (const [logicalId, fn] of Object.entries(functions)) {
    const envVars = fn.Properties?.Environment?.Variables ?? {};
    if ("ALLOW_DEV_AUTH_HEADER" in envVars) {
      violations.push(logicalId);
    }
  }

  if (violations.length > 0) {
    expect.fail(
      `Lambdas with ALLOW_DEV_AUTH_HEADER (production auth bypass risk):\n${violations.join("\n")}`
    );
  }
});
```

### ADR-008 Pass-Through Normalization (Task 8)

Current behavior in `wrapper.ts`: if the inner handler returns an `APIGatewayProxyResult` directly (detected by `isApiGatewayResult`), it's returned as-is — even if it's a non-2xx response with a non-ADR-008 body.

New behavior: for pass-through responses with `statusCode >= 400`, validate the body conforms to ADR-008. If not, wrap it:

```typescript
if (isApiGatewayResult(result)) {
  if (result.statusCode >= 400) {
    try {
      const parsed = JSON.parse(result.body);
      if (!parsed?.error?.code || !parsed?.error?.message) {
        logger.warn("Non-ADR-008 error response detected, normalizing", {
          statusCode: result.statusCode,
        });
        result.body = JSON.stringify({
          error: {
            code: "INTERNAL_ERROR",
            message: parsed?.message || "Unknown error",
            requestId,
          },
        });
      }
    } catch {
      logger.warn("Non-JSON error response detected, normalizing");
      result.body = JSON.stringify({
        error: {
          code: "INTERNAL_ERROR",
          message: "Unknown error",
          requestId,
        },
      });
    }
  }
  return result;
}
```

### Key Files Reference

**Files to create:**
```
backend/test/auth-consistency.test.ts         (AC6 — wrapHandler vs registry)
```

**Files to modify:**
```
infra/test/architecture-enforcement/route-completeness.test.ts  (AC1 — reverse direction)
backend/test/import-enforcement.test.ts                          (AC2 — wrapHandler scan, AC8 — dynamic import)
backend/test/quality-gate-self-test.test.ts                      (AC3 — self-discovering)
backend/functions/api-key-authorizer/handler.ts                  (AC4 — JWT fallback)
backend/functions/api-key-authorizer/handler.test.ts             (AC5 — JWT fallback tests)
infra/test/stacks/auth/auth.stack.test.ts                        (AC7 — dev auth header audit)
backend/shared/middleware/src/wrapper.ts                          (AC9 — pass-through normalization)
backend/shared/middleware/test/wrapper.test.ts                    (AC9 — normalization tests)
backend/shared/db/src/helpers.ts                                  (AC10 — requireEnv extraction)
backend/shared/db/src/users.ts                                    (AC10 — import requireEnv)
backend/shared/db/src/invite-codes.ts                             (AC10 — import requireEnv)
backend/shared/db/test/helpers.test.ts                            (AC10 — requireEnv tests)
backend/test-utils/mock-wrapper.ts                                (AC11, AC12 — production parity)
backend/test-utils/mock-wrapper.test.ts                           (AC11, AC12 — parity tests)
backend/functions/api-keys/handler.test.ts                        (AC13 — enum usage)
backend/functions/invite-codes/handler.test.ts                    (AC13 — enum usage)
```

**Files that MUST NOT be modified:**
```
infra/config/route-registry.ts          (data file — read only in tests)
backend/shared/types/src/errors.ts      (import only — no new error codes needed)
scripts/smoke-test/                      (D6 work — separate concern, run as-is for gate)
```

### Risks & Mitigations

1. **Task 4 (JWT fallback in API key authorizer) is the highest-risk change** — It modifies runtime auth behavior. Mitigate with thorough unit tests (AC5) and post-deployment smoke test validation (AC14). The smoke test already has AC1 (JWT → GET /users/me → 200) which should pass after this fix.

2. **Task 8 (pass-through normalization) changes error response behavior** — Handlers that intentionally return raw error responses will now get them wrapped. Mitigate by only normalizing responses that don't already conform to ADR-008 — conformant responses pass through unchanged. Log a warning when normalization occurs so it's visible in CloudWatch.

3. **Task 1 (reverse-direction test) may initially fail** — If any existing CDK routes are not in the registry, the new test will catch them. This is the intended behavior. Fix by adding missing entries to the registry or removing the extra routes.

4. **Task 4 requires Clerk JWKS access** — The API key authorizer needs the same `CLERK_JWKS_URI` env var as the JWT authorizer. Verify this is already injected by CDK in `AuthStack`. If not, add it.

### Review Provenance (Finding → AC Mapping)

| Finding (Opus) | Finding (GPT-5.2) | AC | Description |
|---|---|---|---|
| Hardening #1 | Top 3 #1 | AC1 | Reverse-direction route test |
| Hardening #3 | — | AC2 | wrapHandler enforcement |
| Hardening #4 | — | AC3 | Self-discovering vitest configs |
| — | Top 3 #2 | AC4, AC5 | jwt-or-apikey semantic fix |
| Hardening #6 | Next 5 #1 | AC6 | wrapHandler vs registry consistency |
| Hardening #5 | Top 3 #3 | AC7 | Dev auth header CDK audit |
| — | Next 5 #2 | AC8 | Dynamic import hardening |
| — | Next 5 #3 | AC9 | ADR-008 pass-through policy |
| D7-R1 Minor #1 | — | AC10 | requireEnv dedup |
| D7-R2 Important #1 | — | AC11 | Mock-wrapper header parity |
| D7-R2 Minor #3 | — | AC12 | Mock-wrapper details parity |
| D7-R2 Minor #1 | — | AC13 | Enum usage in scope tests |

### Git Intelligence

**Commit message pattern:** `feat: <description> (Story 2.1-D9) #<issue>`
**Branch naming:** `story-2-1-d9-foundations-hardening`

**Suggested commit breakdown (one per track):**
1. `test: add reverse-direction route test and wrapHandler enforcement (Story 2.1-D9) #<issue>` — Tasks 1, 2
2. `test: self-discovering vitest configs, auth consistency, dev-header audit (Story 2.1-D9) #<issue>` — Tasks 3, 5, 6
3. `feat: add JWT fallback to API key authorizer (Story 2.1-D9) #<issue>` — Task 4
4. `test: harden import enforcement, add ADR-008 pass-through normalization (Story 2.1-D9) #<issue>` — Tasks 7, 8
5. `refactor: requireEnv dedup, mock-wrapper parity, enum cleanup (Story 2.1-D9) #<issue>` — Tasks 9, 10

### References

- [Source: backend/shared/types/src/foundations_review_opus.md] — Opus adversarial review (full scorecard + hardening plan)
- [Source: backend/shared/types/src/foundations_review_gpt52.md] — GPT-5.2 adversarial review (full scorecard + hardening plan)
- [Source: docs/progress/story-2.1-D7-review-findings-round-1.md] — D7 round 1 findings (5 deferred)
- [Source: docs/progress/story-2.1-D7-review-findings-round-2.md] — D7 round 2 findings (4 deferred)
- [Source: _bmad-output/implementation-artifacts/2.1-D5-architecture-enforcement-tests.md] — T1-T5 test structure
- [Source: _bmad-output/implementation-artifacts/2.1-D7-adversarial-review-fixes.md] — D7 implementation
- [Source: infra/test/architecture-enforcement/route-completeness.test.ts] — T2 current state (registry→CDK only)
- [Source: backend/test/import-enforcement.test.ts] — T6 current state (no wrapHandler check)
- [Source: backend/test/quality-gate-self-test.test.ts] — Static VITEST_CONFIG_PATHS
- [Source: backend/functions/api-key-authorizer/handler.ts] — Current authorizer (x-api-key only)
- [Source: backend/shared/middleware/src/wrapper.ts] — wrapHandler pass-through path
- [Source: backend/shared/middleware/src/auth.ts] — ALLOW_DEV_AUTH_HEADER logic
- [Source: infra/lib/stacks/auth/auth.stack.ts] — Lambda definitions + IAM
- [Source: infra/config/route-registry.ts] — Route registry (canonical source of truth)

## Dev Agent Record

### Agent Model Used

{{agent_model_name_version}}

### Debug Log References

### Completion Notes List

### File List
